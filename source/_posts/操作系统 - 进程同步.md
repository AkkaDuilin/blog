---
title: 操作系统 - 进程同步
date: 2022-10-17 13:32:21   
permalink:         
categories:  
    - 操作系统
    -
    -       
tags: 
    - 操作系统
    - 进程同步    
description:        
image:             
copyright: true     
---

<img src="https://" alt="" style="width:100%" />  

**前言**

操作系统进程同步

多道程序环境下，进程是并发执行的，不同进程间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，达到资源共享和进程协作，避免进程之间的冲突，引入了进程同步的概念。

<!-- more -->

# 竞争条件和临界区
## 竞争条件
- 多个进程并发访问和操作同一数据的情况。
- 共享数据的最终结果取决于**最后操作的进程**
### 解决方法：同步和互斥

## 同步和互斥
### 同步
对多个相关进程在执行次序上协调，并使并发执行的进程见能有效的共享资源和相互合作

### 互斥
进程排他地运行某段代码，任何时候只有一个进程能运行

## 临界资源和临界区

### 临界资源
系统中某些资源一次**只允许一个进程**使用，这种资源称为临界资源  
eg：**共享变量 打印机**

### 临界区
**涉及到临界资源的代码段**
1. 临界区是**代码片段**
2.  进程内代码
3. 进程有一个或多个临界区
4. 设置方法由程序员决定



## 临界区使用准则

### 互斥准则
假定进程Pi在临界区内执行，其他进程将被排斥在自己的临界区外
- 有相同临界资源的临界区都需互斥
- 无相同临界资源的临界区不许互斥

```ad-tip
**一次只允许一个进程使用的资源称为互斥资源**
```


### 有空让进准则
- 临界区无进程执行，不能无限延长下一个要进入临界区进程的等待时间

### 有限等待准则
- 每个进程进入临界区前的等待时间必须有限


```ad-tip
- **进入区**实现互斥准则
- **退出区**实现有空让进准则
- 控制每个临界区大小 实现优先等待准则
```


# 信号量 Semaphore

在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。
## 概念
**一个整型变量**

- 当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；
- 当线程完成一次对semaphore对象的释放（release）时，计数值加一。
- 当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。
- semaphore对象的计数值大于0，为signaled状态，可以获得信号量，**表示有S资源可用**；
	- 计数值等于0，为nonsignaled状态，无法获得信号量，**无资源可用**。
- 计数值小于0，为nonsignaled状态，无法获得信号量，**|S|表示等待进程中的进程个数**

计数信号量具备两种操作动作，称为V（`signal()`）与P（`wait()`）。
V操作会增加信号标S的数值，表示申请一个资源
P操作会减少它，表示释放一个资源
```C++
wait(S){ 
	while(S<=0); 
		S--; 
}
signal(S){ 
	S++; 
}
```

```ad-note
# 信号量S的使用
- S必须置一次且**只能置一次初值**
- S初值不能是负数
- 互斥信号量初始值一般为1
- 同步信号量初始值一般为0～N的整数
- 当为互斥操作时，P、V操作处于同一进程内
- 当为同步操作时，P、V操作在不同进程内
- 同步P在互斥P前
```

## 记录型信号量
解决'盲等'问题 增加了一个进程链表list
记录型信号量可以描述为以下结构体
```C++
Typedef struct{

	Int value；

	Struct process * list；

}semaphore；
```

wait(S) 操作使系统中可供分配的该类资源数减少一个，表示进程请求一个单位的资源
signal(S) 操作使可分配的资源增加一个，表示进程释放一个单位的资源
```C++
wait(semaphore *S){
    S->value--;
    if(S->value < 0)
        block(S->list)；
}

signal(semaphore *S) {     
	S->value++;     
	if(S->value <= 0)         
	wakeup(S->list)； 
}
```


# 三个经典问题

## 单缓存生产者-消费者问题
生产者：生产产品，放入缓冲区
消费者：从缓冲区取产品消费

![[Pasted image 20221023213756.png]]

问题：生产者和消费者对缓冲区互斥访问
**要保证不让生产者在缓存还是满的时候仍然要向内写数据;  
不让消费者试图从空的缓存中取出数据。**



```csharp
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
producer ()//生产者进程 
{
    while(1)
    {
        produce an item in nextp;  //生产数据
        P(empty);  //当empty大于0时，表示有空缓冲区；否则当前生产者阻塞
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //full+1 如果有消费者等在full的队列上，唤醒
    }
}

consumer ()//消费者进程
{
    while(1)
    {
        P(full);  //full>0有满缓冲区，执行；否则阻塞当前消费者
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //empty+1 如果有生产者等在empty的队列上，唤醒
        consume the item;  //消费数据
    }
}
```


## 读者写者问题

问题：
允许多个读者同时读
不允许读者、写者同时读写
不允许多个写者同时写

![[Pasted image 20221023220832.png]]

```C#
semaphore rw = 1;   //实现对文件的互斥访问
int count = 0;
semaphore mutex = 1;//实现对count变量的互斥访问
int i = 0;
writer(){
    while(1){
        P(rw); //写之前“加锁”
        写文件
        V(rw); //写之后“解锁”
    }
}
reader (){
    while(1){
        P(mutex);     //各读进程互斥访问count
        if(count==0)  //第一个读进程负责“加锁”
        {
            P(rw);
        }
        count++;      //访问文件的进程数+1
        V(mutex);
        读文件
        P(mutex);     //各读进程互斥访问count
        count--;      //访问文件的进程数-1
        if(count==0)  //最后一个读进程负责“解锁”
        {
            V(rw);
        }
        V(mutex);
    }
}
```

## 哲学家就餐问题
![[Pasted image 20221023225004.png]]

![[Pasted image 20221023225020.png]]

方法一：设置初始量为4的信号量 seat
方法二：添加检测左右两根筷子的test函数
# xx3x

<hr />
版权信息