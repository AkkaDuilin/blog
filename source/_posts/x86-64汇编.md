---
title: x86-64 汇编语言
categories:
  - null
  - null
  - null
tags:
  - 汇编
  - null
copyright: true
date: 2022-08-01 16:22:24
permalink:
description:
image:
---

<img src="https://" alt="" style="width:100%" />  

**前言**


汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：

程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。
程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在寄存器中的地址。
整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。
条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。
一组浮点寄存器存放浮点数据。


<!-- more -->

# CPU基本功能

1. 执行机器指令
2. 暂存少量数据
3. 访问寄存器

# 数据格式

<a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a>




# 操作数指示符
大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：

1. 立即数(immediate)，也就是常数值
2. 寄存器(register)，表示某个寄存器的内容
3. 寄存器(memory)引用，它会根据计算出来的地址访问某个寄存器位置


<a href="https://sm.ms/image/bJ84KYTCsHigZP7" target="_blank"><img src="https://s2.loli.net/2022/08/02/bJ84KYTCsHigZP7.png" ></a>


# 保护方式和实地址方式

## 保护方式
全部32根地址，寻址4G
支持**虚拟8086方式**

## 实地址方式
对应保护方式下的虚地质。

# 寄存器

## 通用寄存器

IA-32系列有**8个32位寄存器** EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI

8个寄存器的底16位相当于**8个16位寄存器** AX，BX，CX，DX，SP，BP，SI，DI

AX,BX,CX,DX 高、低8位可以分解成**8个独立的8位寄存器**
AH BH CH DH 
AL BL CL DL

## 标志寄存器
1. 进位标志(CF)
- 若运算结果最高位产生进位或借位，置为1 
2. 零标志(ZF)
- 运算结果为0置为1
3. 符号标志(SF)
- 与运算结果最高位相同
4.  溢出标志(OF)
- 反映**有符号数加减运算**是否溢出
- 溢出记为1
5. 奇偶标志(PF)
- 最低字节含有1的位数是偶数还是奇数
- 偶数PF为1
6. 辅助进位标志(AF)
- 最后四位向前有借位或者进位


## 段寄存器
- CPU能够通过地址线直接访问的存储器称为内存
- 程序在存储器中映像有三部分 代码、数据、堆栈
- 物理地址 = 段起始地址 + 偏移
- 逻辑地址二维 物理地址一维
- 段号得到起始地址，加偏移得到物理地址

### 四个段寄存器
1. CS 代码段寄存器
2. SS 堆栈段寄存器
3. DS 数据段寄存器
4. ES 附加段寄存器

- 四个段可以部分重叠可以不连续

## 指令指针寄存器

32位指令指针寄存器EIP

CPU执行程序是一条一条执行的，存储单元的段号和偏移确定了物理地址

CS段寄存器给出当前代码段号，EIP给出偏移

实方式下EIP高16位为0,低16位的IP起作用

取出一条指令后根据指令长度自动调整EIP的值，使其指向下一条指令

# 指令

## 简单指令

1. 数据传送指令 MOV

<a href="https://sm.ms/image/jLvqNehi8JEPsUr" target="_blank"><img src="https://s2.loli.net/2022/08/02/jLvqNehi8JEPsUr.png" ></a>

2. 交换指令 XCHG

XCHG OPRD1,OPRD2

把操作数OPRD1和OPRD2的内容交换
OPRD可以是通用寄存器或者存储单元  两个操作数尺寸必须一致


3. 加法指令 ADD

ADD DEST，SRC

DEST <- DEST + SRC
DEST可以是通用寄存器或者存储单元 SRC寄存器、存储单元或者立即数 操作数尺寸一致 进位溢出

4. 减法指令 SUB

SUB DEST，SRC

DEST <- DEST -SRC
DEST可以是通用寄存器或者存储单元 SRC寄存器、存储单元或者立即数 操作数尺寸一致

5. 减一指令 DEC

DEC DEST

DEC <- DEST - 1
DEST可以是通用寄存器或者存储单元

6. 加一指令 INC

INC DEST

INC <- DEST + 1
DEST可以是通用寄存器或者存储单元

7. 取补指令 NEG

NEG OPRD

OPRD <- 0-OPRD
操作数以补码表示
DEST可以是通用寄存器或者存储单元

## 状态标志指令

1. CLC 
进位清零  CF <- 1

2. STC 
置进位标志 CF <- 0

3. CMC 
进位标志取反

4. LAHF 
获取状态标志
- 将状态寄存器低8位送到AH中

5. SAHF
设置状态标志
使状态标志成为AH中对应值

## 带进位加减法
1. ADC
ADC DEST,SRC

DEST <- DEST + SRC + CF
- SRC 可以是立即数、通用寄存器、存储单元
- DEST 可以是通用寄存器或存储单元
- 两个操作数尺寸必须一致

2. SBB
SBB DEST,SRC---
title: 计算机组成笔记-主存储器
categories:

  - 计算机组成原理
  - null
tags:
  - 主存储器
  - 计组
copyright: true
date: 2022-04-23 15:59:21
permalink:
description:
image:
---

<img src="https://" alt="" style="width:100%" />  

**前言**

计算机组成原理

主存储器


<a href="https://sm.ms/image/UQvDjshEwNZuA92" target="_blank"><img src="https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg" ></a>

<!-- more -->

# 概述

<a href="https://sm.ms/image/nJjHB8GmbpCu14X" target="_blank"><img src="https://s2.loli.net/2022/04/23/nJjHB8GmbpCu14X.jpg" alt="Screenshot 2022-04-12 144845.jpg"></a>


1. 主要指标：主存容量、储存器存储时间(启动一次读写操作到完成该操作的时间)、存储周期(连续启动两次独立的储存器操作所需间隔的最小时间)

2. 一个字节 = 8个二进制位

3. 总线：地址总线、数据总线、控制总线 连接主存储器和CPU
 
4. AR(地址寄存器)K位 DR(数码寄存器)n位 允许主存包含2^K个可寻址的字节 在一个存储周期内，CPU和主存通过总线进行n位数据传送。


# RAM

半导体读/写存储器按存储元件在运行中能否长时间保存信息来分为静态存储器（SRAM）和动态存储器（DRAM）。
其中SRAM利用双稳态触发器来保存信息,而且只要不断电,信息不会丢失,
DRAM使用MOS电容来保存信息,使用时需要不断给电容充电。

<a href="https://sm.ms/image/pu7XfFymj3beQW9" target="_blank"><img src="https://s2.loli.net/2022/04/23/pu7XfFymj3beQW9.jpg" ></a>

## SRAM

静态RAM是利用双稳态触发器来记忆信息的。六管静态MOS记忆单元电路中的T1～T4组成两个反相器，交叉耦合连接成一个触发器；T1～T6管构成一个记忆单元的主体，能存放一位二进制信息。


### SRAM的读写

<a href="https://sm.ms/image/TcMNbC6OUJIL1ik" target="_blank"><img src="https://s2.loli.net/2022/04/23/TcMNbC6OUJIL1ik.png" ></a>

存储单元未被选中时，字选择线保持低电位，两位线保持高电位；单元被选中时，字选择线保持高电位。
<a href="https://sm.ms/image/LHjvTfwScrnu2X7" target="_blank"><img src="https://s2.loli.net/2022/04/23/LHjvTfwScrnu2X7.png" ></a>

由存储单元组成的存储器结构和功能表如下:

<a href="https://sm.ms/image/g1dLcKMHYA46eSX" target="_blank"><img src="https://s2.loli.net/2022/04/23/g1dLcKMHYA46eSX.png" ></a>

### 读写时序

<a href="https://sm.ms/image/1mBpUZ6OlN3zSoe" target="_blank"><img src="https://s2.loli.net/2022/04/23/1mBpUZ6OlN3zSoe.jpg" ></a>

<a href="https://sm.ms/image/9dAgNRVwfpqcYKF" target="_blank"><img src="https://s2.loli.net/2022/04/23/9dAgNRVwfpqcYKF.jpg" ></a>

## DRAM

### 结构

**储存单元**

<a href="https://sm.ms/image/8c2nm7i9VG1AJvs" target="_blank"><img src="https://s2.loli.net/2022/04/23/8c2nm7i9VG1AJvs.png" ></a>

**写入**: 字线为高电平,T导通
写1: 位线为低电平,VDD通过T对Cs充电，  电容中有电荷则保持不变。
写0: 位线为高电平,Cs通过T放电，电容中无电荷则不变。

**读出**:位线预充电至高电平; 当字线出现高电平后,T导通,若原来Cs充有电荷,则Cs放电,使位线电位下降,经放大后,读出为1; 若原来Cs上无电荷,则位线无电位变化,放大器无输出,读出为0。
读出后,若原来Cs充有电荷也被放掉了,和没有充电一样,因此读出是破坏性的,故读出后要立即对单元进行“重写”,以恢复原信息。

**储存器**

16K由两个64*128矩阵组成
WE为允许信号，若为0，执行写操作，Din通过T7T8以及T5T6进入单元
为1执行读操作，单元的状态通过位线1 位线2和T7T8传至读放
若CS = 1 不进行读写操作
<a href="https://sm.ms/image/BSKJy8L15fWlOd4" target="_blank"><img src="https://s2.loli.net/2022/04/23/BSKJy8L15fWlOd4.png" ></a>


### 刷新

<a href="https://sm.ms/image/3jAh5Px18slzZIi" target="_blank"><img src="https://s2.loli.net/2022/04/23/3jAh5Px18slzZIi.jpg" ></a>

## 发展

1. SDRAM —— 同步动态随机读写存储器
将CPU与RAM通过一个相同的时钟信号锁在一起，使RAM和CPU能够共享一个时钟周期，以相同的速度同步工作。在每一个时钟脉冲的上升沿开始传送数据。

2. DDR —— 双倍数据传输速率同步动态随机存储器
是SDRAM的一种新技术。
可在同一时钟周期的上升和下降沿都能传送数据，同样时间内的数据传送量翻了一倍。

# ROM

停电时信息不丢失的存储器称为非易失性存储器。
可分为ROM、 PROM、EPROM、 E2 PROM 和 flash memory。

芯片的内容在制造时已经输入，只能读，不能修改。
存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。
存储元件：二极管或晶体管

# 容量扩展

1 bit  = 8 位

**数据线数目 = 芯片位长**

**存储器容量=字数*位长**

**地址线数 = log2(字数)**




## 位扩展

位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。

eg:

两个16K* 4位的芯片采用位扩展方式扩展成一16K * 8 位的存储器。如下图所示。 16K * 4位的芯片的字长为4位，所以有4条数据线，分别用D0~D3和D4~D7表示；容量为16K = 2^14 ，有14条地址线，用A0~A13 表示。

<a href="https://sm.ms/image/9GQzPrZYRTU6dtp" target="_blank"><img src="https://s2.loli.net/2022/04/23/9GQzPrZYRTU6dtp.png" ></a>


## 字扩展

字扩展是指仅在容量方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。64K*8位的存储器需要4个16K*8位芯片组成，连接图如下。

<a href="https://sm.ms/image/CBHkpyxucihlNUZ" target="_blank"><img src="https://s2.loli.net/2022/04/23/CBHkpyxucihlNUZ.png" ></a>

数据线D0 - D7线与各片的数据端相连，地址总线（共16条）低位A0 -A13 与各芯片的14个地址端相连，两位高位A14和A15经过译码器和4个片选端相连。
在同一时间内四个芯片中只能有一个芯片被选中。

## 同时扩展

当构成一个容量较大的存储器时，往往需要在字方向和位方向上同时扩展，这将是前两种扩展的组合，实现起来也是很容易的。

一个存储器的容量为M*N位，若使用L*K位存储器芯片，需要(M/L)*(N/K)个芯片

如用16K×4位的SRAM组成64K×8位的存储器，需要8个芯片。



# xx3x

<hr />
版权信息

DEST <- DEST - (SRC+CF)
- SRC 可以是立即数、通用寄存器、存储单元
- DEST 可以是通用寄存器或存储单元
- 两个操作数尺寸必须一致
## 乘除运算指令
**unfinished**
## 取有效地址
- LEA REG，OPRD
将操作数OPRD的有效地址传送到REG中
OPRD 存储器操作数 REG 16位或32位寄存器

## 条件转移指令
用于改变EIP的内容的指令
条件转移目的地仅限于同一个代码段中

![[Pasted image 20220928082947.png]]

## 无条件转移
JMP LAB 
使控制无条件转移到标号LAB处

## 比较指令
CMP DEST，SRC
根据 DEST-SRC的差来影响标志寄存器的各状态标志，但不将结果送至DEST

## 过程调用和返回指令
- 子程序称为过程 调用子程序本质是**控制转移** 
- 过程调用用于由主程序转移到子程序时使用
1. CALL LAB
LAB 可以是程序中的一个标号或者过程名
过程：1.  把地址偏移(EIP内容)压入堆栈 2. 使得EIP内容为目标地址偏移

2. RET 
从堆栈弹出地址偏移，送到指令指针寄存器EIP

# 参数传递
主程序 -> 子程序 入口参数
子程序 -> 主程序 出口参数

C语言通常用堆栈传递入口参数 用寄存器传递出口参数
```C++
int  cf35(int  x, int  y)
{
    if  (x < y)  x = y;
    return  x;
}


cf35    PROC              ;表示过程（函数）开始
    push  ebp             ;
    mov   ebp, esp        ;建立堆栈框架
    mov   eax, DWORD PTR  [ebp+8]            ;从堆栈取参数x
    mov   ecx, DWORD PTR  [ebp+12]           ;从堆栈取参数y
    cmp   eax, ecx        ;比较x和y（EAX代表x，ECX代表y）
    jge   SHORT ln1cf35   ;如果x大于等于y，就跳转
    mov   eax, ecx        ;实现x=y
ln1cf35:
    pop   ebp             ;撤销堆栈框架
    ret                   ;返回
cf35    ENDP              ;表示过程（函数）结束

```

# 局部变量
求累加和安排两个局部变量 
```C++
int  cf37(int  n)
{
    int  i, sum;
    sum = 0;
    for ( i=1; i <= n; i++ )
        sum += i;
    return  sum;
}


cf37    PROC            ;表示过程（函数）开始
    push  ebp
    mov   ebp, esp      ;建立堆栈框
    sub   esp, 8                         ;安排局部变量i和sum
    mov   DWORD PTR  [ebp-8], 0          ;sum=0;
    mov   DWORD PTR  [ebp-4], 1          ;i=1;
    jmp   SHORT  LN3cf37
LN2cf37:                                 ;i++
    mov   eax, DWORD PTR  [ebp-4]        ;取出i
    add   eax, 1
    mov   DWORD PTR  [ebp-4], eax        ;送回i
LN3cf37:                                 ;比较i和n
    mov   ecx, DWORD PTR  [ebp-4]
    cmp   ecx, DWORD PTR  [ebp+8]
    jg   SHORT  LN1cf37                  ;如果i大于n，则跳转
                                         ;sum += i;
    mov   edx, DWORD PTR  [ebp-8]
    add   edx, DWORD PTR  [ebp-4]
    mov   DWORD PTR  [ebp-8], edx
    jmp   SHORT  LN2cf37
LN1cf37:
    mov   eax, DWORD PTR  [ebp-8]         ;准备返回参数
    mov   esp, ebp                        ;撤销局部变量
    pop   ebp
    ret
cf37    ENDP

```


# 寻址方式

## 立即寻址
MOV EAX,12345678H
- 操作数本身包含在指令中，跟在操作码之后存放在代码段中
- 这样的操作数称为立即数
- 采用“高高低低”原则
- 只有源操作数可以使用立即寻址


## 寄存器寻址
MOV EBP,ESP
- 操作数保存在CPU内部寄存器 指令中指定寄存器

## 存储器寻址

### 存储器直接寻址
MOV ECX,[95480H]
指令包含操作数所在的存储单元的有效地址

### 存储器间接寻址
MOV EAX,[ESI]
通过寄存器间接给出存储单元有效地址的方式

### 间接相对寻址
MOV EAX,[EBX + 12H]

### 基址变址寻址
MOV EAX,[EAX+EBX]

### 基址变址相对寻址
MOV EAX,[EAX+EBX+12H]

## 通用表示
- 三部分内容相加
	- 32位基地址寄存器的起始地址
	- 可乘比例因子的变址寄存器
	- 8位、16位、32位的位移量
三部分可省去任意两部分


# 堆栈
一段内存区域，对它的访问操作仅限于一端进行
堆寄存器SS含有当前堆栈段的段号，指示堆栈所在的内存区域
堆栈指针寄存器ESP含有栈顶的偏移(有效地址)，**指向栈顶**
进栈操作ESP减小，出栈操作ESP增大

用途：
1. 保护寄存器内容或现场
2. 保存返回地址
3. 传递参数
4. 安排局部变量或临时变量

## 指令
1. PUSH SRC
- 把源操作数SRC压入堆栈 SRC可以是32位和16位寄存器 字或者双字存储单元 立即数
- 把一个**双字**/**字** 数据压入堆栈时，先**ESP -4** / **ESP -2** 再把数据送到ESP指示的存储单元
- ESP 指向栈顶

2. POP DEST
- 从栈顶弹出一个双字或者字数据到目的操作数DEST。 
- 出栈指令至少弹出一个字
- 从栈顶弹出一个**双字数据**/**字数据** 先将ESP指示的存储单元取出一个双字送到目的操作数，然后**ESP + 4** / **ESP + 2**

3. 全出栈/进栈命令
- PUSHA /POPA 十六位通用寄存器命令
	- 将寄存器 AX、CX、DX、BX、SP、BP、SI、DI 依次压入堆栈
	- 弹出时以PUSHA相反的顺序送入通用寄存器
- PUSHAD/POPAD 三十二位通用寄存器命令
	- EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI 依次压入堆栈
	- 弹出时以PUSHA相反的顺序送入通用寄存器
# xxx


<hr />
版权信息