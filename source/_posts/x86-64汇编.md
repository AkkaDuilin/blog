---
title: x86-64 汇编语言
categories:
  - 汇编语言
  - null
  - null
tags:
  - 汇编语言
  - null
copyright: true
date: 2022-08-01 16:22:24
permalink:
description:
image:
---

<img src="https://" alt="" style="width:100%" />  

**前言**


汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：
程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在寄存器中的地址。
整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。
条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。
一组浮点寄存器存放浮点数据。


<!-- more -->

# CPU基本功能

1. 执行机器指令
2. 暂存少量数据
3. 访问寄存器

# 数据格式

<a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a>




# 操作数指示符
大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：

1. 立即数(immediate)，也就是常数值
2. 寄存器(register)，表示某个寄存器的内容
3. 寄存器(memory)引用，它会根据计算出来的地址访问某个寄存器位置

``` ad-note
<a href="https://sm.ms/image/bJ84KYTCsHigZP7" target="_blank"><img src="https://s2.loli.net/2022/08/02/bJ84KYTCsHigZP7.png" ></a>

```
`

# 保护方式和实地址方式

## 保护方式
- 全部32根地址，寻址4G
- 支持**虚拟8086方式**

## 实地址方式
- 对应保护方式下的虚地质。

# 寄存器

## 通用寄存器

- IA-32系列有**8个32位寄存器** EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI

- 8个寄存器的底16位相当于**8个16位寄存器** AX，BX，CX，DX，SP，BP，SI，DI

- AX,BX,CX,DX 高、低8位可以分解成**8个独立的8位寄存器**AH BH CH DH AL BL CL DL

## 标志寄存器
### 进位标志(CF)
- 若运算结果最高位产生进位或借位，置为1 
### 零标志(ZF)
- 运算结果为0置为1
###  符号标志(SF)
- 与运算结果最高位相同
###  溢出标志(OF)
- 反映**有符号数加减运算**是否溢出
- 溢出记为1
### 奇偶标志(PF)
- 最低字节含有1的位数是偶数还是奇数
- 偶数PF为1
### 辅助进位标志(AF)
- 最后四位向前有借位或者进位

```ad-note
标志寄存器用于判断数大小
# 无符号数的比较:
1. CF=0,前者大于或等于后者;
2. CF=1,前者小于后者;

# 带符号数的比较:
1. 如果结果是OF=0,且SF=0（正）,或者当OF=1,且SF=1（负）时,说明两个数是前者大于或等于后者。
2. 如果结果是OF=0,且SF=1（负）,或者当OF=1,且SF=0（正）时,说明两个数是前者小于后者。

```

## 段寄存器
- CPU能够通过地址线直接访问的存储器称为内存
- 程序在存储器中映像有三部分 代码、数据、堆栈
- 物理地址 = 段起始地址 + 偏移
- 逻辑地址二维 物理地址一维
- 段号得到起始地址，加偏移得到物理地址

### 四个段寄存器
1. CS 代码段寄存器
2. SS 堆栈段寄存器
3. DS 数据段寄存器
4. ES 附加段寄存器

- 四个段可以部分重叠可以不连续

## 指令指针寄存器

- 32位指令指针寄存器EIP

- CPU执行程序是一条一条执行的，存储单元的段号和偏移确定了物理地址

- CS段寄存器给出当前代码段号，EIP给出偏移

- 实方式下EIP高16位为0,低16位的IP起作用

- 取出一条指令后根据指令长度自动调整EIP的值，使其指向下一条指令

# 指令

## 简单指令

### 数据传送指令 MOV
```ad-note
<a href="https://sm.ms/image/jLvqNehi8JEPsUr" target="_blank"><img src="https://s2.loli.net/2022/08/02/jLvqNehi8JEPsUr.png" ></a>
```


### 交换指令 XCHG

- **XCHG OPRD1,OPRD2**
- 把操作数OPRD1和OPRD2的内容交换
- OPRD可以是通用寄存器或者存储单元  两个操作数尺寸必须一致


### 加法指令 ADD

- **ADD DEST，SRC**
- DEST <- DEST + SRC
- DEST可以是通用寄存器或者存储单元 SRC寄存器、存储单元或者立即数 操作数尺寸一致 **进位溢出**

### 减法指令 SUB

- **SUB DEST，SRC**

- DEST <- DEST -SRC
- DEST可以是通用寄存器或者存储单元 SRC寄存器、存储单元或者立即数 操作数尺寸一致
### 减一指令 DEC

- **DEC DEST**
- DEC <- DEST - 1
- DEST可以是通用寄存器或者存储单元

### 加一指令 INC

- **INC DEST**

- INC <- DEST + 1
- DEST可以是通用寄存器或者存储单元

### 取补指令 NEG

- NEG OPRD

- OPRD <- 0-OPRD
- 操作数以补码表示
- DEST可以是通用寄存器或者存储单元

## 状态标志指令

###  CLC 
- 进位清零  CF <- 1

### STC 
- 置进位标志 CF <- 0

### CMC 
- 进位标志取反

### LAHF 
- 获取状态标志
- 将状态寄存器低8位送到AH中

### SAHF
- 设置状态标志
- 使状态标志成为AH中对应值

## 比较指令
- CMP DEST，SRC
- 根据 DEST-SRC的差来影响标志寄存器的各状态标志，但不将结果送至DEST

## 带进位加减法
### ADC
- **ADC DEST,SRC**
- DEST <- DEST + SRC + CF
- SRC 可以是立即数、通用寄存器、存储单元
- DEST 可以是通用寄存器或存储单元
- 两个操作数尺寸必须一致

### SBB
- **SBB DEST,SRC**
- DEST <- DEST - (SRC+CF)
- SRC 可以是立即数、通用寄存器、存储单元
- DEST 可以是通用寄存器或存储单元
- 两个操作数尺寸必须一致
## 乘除运算指令
### 无符号乘法
- **MUL OPRD**
- 如果OPRD是 字节/字/双字 操作数，则把 AL/AX/EAX 中的无符号数与OPRD相乘，结果送到 AX/DX:AX/EDX:EAX 中
- OPRD可以是通用寄存器/存储单元 
- DX/EDX 存高位 AX/EAX存低位
- 如果乘积**高半部分不为0**,则标志**CF = 1 OF = 1 否则都为0**


### 有符号乘法
#### IMUL OPRD
- 与MUL相同
- 乘积高半部分位含有有效位CF = 1,OF = 1否则为0
#### IMUL DEST,SRC
- DEST <- DEST * SRC 
- DEST 只能是16/32位通用寄存器
- SRC 通用寄存器/存储单元(与目的操作数尺寸一致)/立即数(不超过目的操作数) 
- **因为溢出而将高位截掉CF = 1,OF = 1 否则为0**
#### IMUL DEST,SRC1,SRC2
- DEST <- SRC1 * SRC2
- DEST 只能是16/32位通用寄存器
- SRC1 通用寄存器/存储单元(尺寸一致)
- **SRC2 只能是立即数**(不超过目的操作数)
- **因为溢出而将高位截掉CF = 1,OF = 1 否则为0**

### 无符号除法
- **DIV OPRD**
- 被除数位于寄存器AX、寄存器对DX:AX、寄存器对EDX:EAX 
- 如果OPRD是字节操作数，则把**AX中的无符号数除以OPRD，商送到AL，余数送到AH**
- 如果OPRD是字操作数，则把寄存器DX:AX中的无符号数除以OPRD，商送到AX，余数送到DX
- 如果OPRD是双字操作数，则把寄存器EDX:EAX中的无符号数除以OPRD，商送到EAX，余数送到EDX
- **如果除数为0或者商太大(商超过寄存器最大值)，则将引起除法出错异常** 

### 有符号除法
- **IDIV OPRD**
- 被除数位于寄存器AX、寄存器对DX:AX、寄存器对EDX:EAX 
- 将被除数和除数看作是有符号数，其他情况与DIV一致
- 如果不能整除，则余数的符号与被除数一致，且余数的绝对值小于除数的绝对值
- 如果除数为0,商太大或太小，则引起除法出错一场

## 扩展指令
### 符号扩展指令
- 用于解决避免因商太大或者太小引起除法出错异常
#### 字节转化为字
##### CBW 
- 将寄存器AL的符号扩展到寄存器AH
- 若AL最高有效位=0,AH=0
- 若AL最高有效为=1,AH = 0FFH

#### 字转化为双字
##### CWD
- 将寄存器AX的符号扩展到寄存器DX
- 若AX最高有效位 = 0 , DX=0
- 若AX最高有效为 = 1 , DX = 0FFFFH
##### CWDE
- 将寄存器AX的符号扩展到寄存器EAX
- 若AX最高有效位 = 0 , EAX高16位为0
- 若AX最高有效为 = 1 , EAX高16位为1

#### 双字转化为四字
##### CDQ
- 将寄存器EAX的符号扩展到寄存器EDX
- 若AX最高有效位 = 0 , DX=0
- 若AX最高有效为 = 1 , DX = 0FFFFFFFFH 

### 扩展传送指令
#### 符号扩展传送指令
- **MOVSX DEST,SRC**
- 最高位为1全填1,最高位为0全填0
- 将源操作数SRC符号扩展后送至DEST
- 目的操作数尺寸必须大于源操作数尺寸
- 不改变源操作数
#### 零扩展传送指令
- **MOVZX DEST,SRC**
- 把源操作数SRC零扩展后送至目标操作数DEST
- 全填0
## 逻辑运算指令

### NOT
- **NOT OPRD**
- 取反指令0变1 1变0
- 结果送至OPRD
### AND
- **AND DEST,SRC**
- 进行按位的“与”运算 都为1时为1
- 结果送至SRC 
### OR
- **OR DEST,SRC**
- 进行按位的”或“运算 都为0时为0
### XOR
- **XOR DEST,SRC**
- 进行按位的“异或”运算 对应位不同即为1,否则为0
### TEST
- **TEST DEST,SRC**
- 进行按位的“与”运算
- 仅影响状态标志 ZF,PF,SF反映运算结果 CF,OF清为0
## 移位指令
### 一般移位指令
#### 左移指令
- SAL OPRD,count 算术左移
- SHL OPRD,count 逻辑左移
- OPRD 通用存储器/存储单元 **count 8位立即数/CL寄存器**
- 将操作数OPRD左移count位
- 每向左移动一位，右端补一个0
- **移出的最高位进入CF**
- **相当于乘以2**
#### 算术右移
- SAR OPRD,count 算术右移
- OPRD 通用存储器/存储单元 **count 8位立即数/CL寄存器**
- 将操作数OPRD右移count位
- 每向右移动一位，**左端符号位不变**
- 移出的最低位进入CF
- **相当于除以2**

#### 逻辑右移
- SHR OPRD,count 逻辑右移
- OPRD 通用存储器/存储单元 **count 8位立即数/CL寄存器**
- 将操作数OPRD右移count位
- 每向右移动一位，**左端补一个0**
- 移出的最低位进入CF
- **对无符号数来说相当于除以2**
### 循环移位指令
- OPRD 通用存储器/存储单元 **count 8位立即数/CL寄存器(截取低五位)**
- CF/OP 受影响
#### ROL 
- ROL OPRD,count 左循环移位
- 操作数循环左移count位，每向左一位**最高位移入最低位**，同时**最高位也移入CF**
#### ROR
- ROR OPRD,count 右循环移位
- 操作数循环右移count位，每向右一位**最低位移入最高位**，同时**最低位也移入CF**
#### RCL
- RCL OPRD,count 带进位左循环移位
- 操作数连同CF循环左移count位，每向左一位，**最高位进入CF**，**CF进入最低位**
#### RCR
- RCR OPRD,count 带进位右循环移位
- 操作数连同CF循环右移count位，每向右一位，**最低位进入CF**，**CF进入最高位**
### 双精度移位
#### SHLD
- SHLD OPRD1,OPRD2,count
- OPRD1操作数左移指定count位，**低端空位**用操作数**OPRD2高端的count位补充**，OPRD2内容不变，OPRD1中**最后移出的位保留在进位标志CF**

#### SHRD
- SHLD OPRD1,OPRD2,count
- OPRD1操作数右移指定count位，**高端空位**用操作数**OPRD2低端的count位补充**，OPRD2内容不变，OPRD1中**最后移出的位保留在进位标志CF**


## 取有效地址
- LEA REG，OPRD
- 将操作数OPRD的有效地址传送到REG中
- OPRD 存储器操作数 REG 16位或32位寄存器

## 条件转移指令
- 用于改变EIP的内容的指令
- 条件转移目的地仅限于同一个代码段中 段内转移
```ad-note

![[Pasted image 20220928082947.png]]

```

## 无条件转移
- JMP LAB 
- 使控制无条件转移到标号LAB处


## 过程调用和返回指令
- 子程序称为过程 调用子程序本质是**控制转移** 
- 过程调用用于由主程序转移到子程序时使用
### CALL LAB
- LAB 可以是程序中的一个标号或者过程名
- 过程：1.  把地址偏移(EIP内容)压入堆栈 2. 使得EIP内容为目标地址偏移
### RET 
- 从堆栈弹出地址偏移，送到指令指针寄存器EIP

# 参数传递
- 主程序 -> 子程序 入口参数
- 子程序 -> 主程序 出口参数

- C语言通常用堆栈传递入口参数 用寄存器传递出口参数
```C++
int  cf35(int  x, int  y)
{
    if  (x < y)  x = y;
    return  x;
}


cf35    PROC              ;表示过程（函数）开始
    push  ebp             ;
    mov   ebp, esp        ;建立堆栈框架
    mov   eax, DWORD PTR  [ebp+8]            ;从堆栈取参数x
    mov   ecx, DWORD PTR  [ebp+12]           ;从堆栈取参数y
    cmp   eax, ecx        ;比较x和y（EAX代表x，ECX代表y）
    jge   SHORT ln1cf35   ;如果x大于等于y，就跳转
    mov   eax, ecx        ;实现x=y
ln1cf35:
    pop   ebp             ;撤销堆栈框架
    ret                   ;返回
cf35    ENDP              ;表示过程（函数）结束

```

# 局部变量
- 求累加和安排两个局部变量 
```C++
int  cf37(int  n)
{
    int  i, sum;
    sum = 0;
    for ( i=1; i <= n; i++ )
        sum += i;
    return  sum;
}


cf37    PROC            ;表示过程（函数）开始
    push  ebp
    mov   ebp, esp      ;建立堆栈框
    sub   esp, 8                         ;安排局部变量i和sum
    mov   DWORD PTR  [ebp-8], 0          ;sum=0;
    mov   DWORD PTR  [ebp-4], 1          ;i=1;
    jmp   SHORT  LN3cf37
LN2cf37:                                 ;i++
    mov   eax, DWORD PTR  [ebp-4]        ;取出i
    add   eax, 1
    mov   DWORD PTR  [ebp-4], eax        ;送回i
LN3cf37:                                 ;比较i和n
    mov   ecx, DWORD PTR  [ebp-4]
    cmp   ecx, DWORD PTR  [ebp+8]
    jg   SHORT  LN1cf37                  ;如果i大于n，则跳转
                                         ;sum += i;
    mov   edx, DWORD PTR  [ebp-8]
    add   edx, DWORD PTR  [ebp-4]
    mov   DWORD PTR  [ebp-8], edx
    jmp   SHORT  LN2cf37
LN1cf37:
    mov   eax, DWORD PTR  [ebp-8]         ;准备返回参数
    mov   esp, ebp                        ;撤销局部变量
    pop   ebp
    ret
cf37    ENDP

```


# 寻址方式

## 立即寻址
- MOV EAX,12345678H
- 操作数本身包含在指令中，跟在操作码之后存放在代码段中
- 这样的操作数称为立即数
- 采用“高高低低”原则
- 只有源操作数可以使用立即寻址


## 寄存器寻址
- MOV EBP,ESP
- 操作数保存在CPU内部寄存器 指令中指定寄存器

## 存储器寻址

### 存储器直接寻址
- MOV ECX,[95480H]
- 指令包含操作数所在的存储单元的有效地址

### 存储器间接寻址
- MOV EAX,[ESI]
- 通过寄存器间接给出存储单元有效地址的方式

### 间接相对寻址
- MOV EAX,[EBX + 12H]

### 基址变址寻址
- MOV EAX,[EAX+EBX]

### 基址变址相对寻址
- MOV EAX,[EAX+EBX+12H]

## 通用表示
- 三部分内容相加
	- 32位基地址寄存器的起始地址
	- 可乘比例因子的变址寄存器
	- 8位、16位、32位的位移量
- 三部分可省去任意两部分


# 堆栈
- 一段内存区域，对它的访问操作仅限于一端进行
- 堆寄存器SS含有当前堆栈段的段号，指示堆栈所在的内存区域
- 堆栈指针寄存器ESP含有栈顶的偏移(有效地址)，**指向栈顶**
- 进栈操作ESP减小，出栈操作ESP增大

## 用途：
1. 保护寄存器内容或现场
2. 保存返回地址
3. 传递参数
4. 安排局部变量或临时变量

## 指令
### PUSH SRC
- 把源操作数SRC压入堆栈 SRC可以是32位和16位寄存器 字或者双字存储单元 立即数
- 把一个**双字**/**字** 数据压入堆栈时，先**ESP -4** / **ESP -2** 再把数据送到ESP指示的存储单元
- ESP 指向栈顶
- 高高低低原则

### POP DEST
- 从栈顶弹出一个双字或者字数据到目的操作数DEST。 
- 出栈指令至少弹出一个字
- 从栈顶弹出一个**双字数据**/**字数据** 先将ESP指示的存储单元取出一个双字送到目的操作数，然后**ESP + 4** / **ESP + 2**

### 全出栈/进栈命令
#### PUSHA /POPA 十六位通用寄存器命令
	- 将寄存器 AX、CX、DX、BX、SP、BP、SI、DI 依次压入堆栈
	- 弹出时以PUSHA相反的顺序送入通用寄存器
#### PUSHAD/POPAD 三十二位通用寄存器命令
	- EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI 依次压入堆栈
	- 弹出时以PUSHA相反的顺序送入通用寄存器


# 分支程序

# 循环程序
## 循环指令
### 循环指令
#### 计数器循环指令
- **LOOP LABEL**
- 使寄存器ECX的值减1，若结果不等于0,则转移到标号LABEL处，否则顺序执行LOOP之后的指令

#### 等于/全零循环指令
- **LOOPE LABEL**
- **LOOPZ LABEL**
- 使寄存器ECX的值减1,如果**结果不为0**,并且**零标志ZF = 1**，那么转移到标号LABEL处，否则顺序执行
- 不影响标志

#### 不等于/非零循环指令
- **LOOPNE LABEL**
- **LOOPNZ LABEL**
- 使寄存器ECX的值建1,如果**结果不等于0**,并且**零标志ZF = 0**,则转移到LABEL处
- 不影响标志

### 计数器转移指令
- **JECXZ LABEL**
- 当**ECX的值为0**时**转移到LABEL**

# xxx


<hr />
版权信息